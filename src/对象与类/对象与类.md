# 对象与类

## 类

1. 所有的类都源自于一个超类Object

## 对象

对象的三个特性

1. 对象的行为
2. 对象的状态
3. 对象的标识

## 识别类

识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。

## 类之间的关系

### 依赖(use-a)

		例如Order类使用Account类,是因为,Order对象需要访问 Account对象查看信用状态,而Item类不依赖于Account类,是因为,Item对象与账户对象无关,所以一个类的方法操控另一个类的对象,我们就说一个类 依赖于另一个类

		**应该尽可能的将相互之间的依赖的类减至最小** ,类A如果不知道B的存在那么他就不会关心B的任何改变,也不会因为B的改变产生BUG,之间的耦合度最小

### 聚合(has-a)

	一个Order对象包含Item对象,聚合意味着,类A的对象包含类B的对象

### 继承(is-a)

	子类继承自父类

## 预定义类

### 对象和对象变量

```java
public class ObjectAndClass {
  public static void main(final String[] args) {
    final Date time = new Date();
    System.out.print(time);
  }
}
```

对象和对象变量有非常重要的区别

```java
final Date deadLine;
deadLine.toString()   // 报错,必须先初始化变量
```

在java中,任何变量的值都是对存储在另外一个地方的变量的引用

```java
public class ObjectAndClass {
  public static void main(final String[] args) {
   final Date time = new Date();
    // 静态工厂方法
    final LocalDate localTime = LocalDate.now();
    final int[] localTimeArray = new int[3];
    localTimeArray[0] = localTime.getYear();
    localTimeArray[1] = localTime.getMonthValue();
    localTimeArray[2] = localTime.getDayOfMonth();
    System.out.println(Arrays.toString(localTimeArray)); // [2020, 8, 26]
    System.out.println(time); // Wed Aug 26 20:52:53 CST 2020
    System.out.println(localTime); // 2020-08-26
    // 类库设计者决定将保存时间与给时间点命名分开,所以java类库包含了两个类,一个是用来表示时间点的	   Date类,另一个是表示熟悉的日历表示法的LocalDate类
    final LocalDate newYear = LocalDate.of(1992, 12, 31);
    final LocalDate otherYear = newYear.plusDays(1000); // 距离当今天数的指定日期
    // 会生成一个新的LocalDate数组
    System.out.print(otherYear); // 1995-09-27
    // 调用方法后这个对象的状态会被改变的方法称为更改器方法
    // 只访问对象而不修改对象的方法被称为访问器方法
  }
}
```

```____```